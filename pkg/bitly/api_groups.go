/*
Bitly API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 4.0.0
Contact: api@bitly.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type GroupsApi interface {

	/*
		GetGroup Retrieve a Group

		Returns details for a group.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetGroupRequest
	*/
	GetGroup(ctx _context.Context, groupGuid string) ApiGetGroupRequest

	// GetGroupExecute executes the request
	//  @return Group
	GetGroupExecute(r ApiGetGroupRequest) (Group, *_nethttp.Response, error)

	/*
		GetGroupClicks GetByCountries clicks by group

		get number of clicks on bitlinks in a group

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetGroupClicksRequest
	*/
	GetGroupClicks(ctx _context.Context, groupGuid string) ApiGetGroupClicksRequest

	// GetGroupClicksExecute executes the request
	//  @return GroupClicks
	GetGroupClicksExecute(r ApiGetGroupClicksRequest) (GroupClicks, *_nethttp.Response, error)

	/*
		GetGroupMetricsByCities GetByCountries Click Metrics for a Group by City

		Returns the geographic origins of click traffic by city for the specified group.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetGroupMetricsByCitiesRequest
	*/
	GetGroupMetricsByCities(ctx _context.Context, groupGuid string) ApiGetGroupMetricsByCitiesRequest

	// GetGroupMetricsByCitiesExecute executes the request
	//  @return CityMetrics
	GetGroupMetricsByCitiesExecute(r ApiGetGroupMetricsByCitiesRequest) (CityMetrics, *_nethttp.Response, error)

	/*
		GetGroupMetricsByCountries GetByCountries Click Metrics for a Group by Country

		Returns the geographic origins of click traffic by country for the specified group.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetGroupMetricsByCountriesRequest
	*/
	GetGroupMetricsByCountries(ctx _context.Context, groupGuid string) ApiGetGroupMetricsByCountriesRequest

	// GetGroupMetricsByCountriesExecute executes the request
	//  @return ClickMetrics
	GetGroupMetricsByCountriesExecute(r ApiGetGroupMetricsByCountriesRequest) (ClickMetrics, *_nethttp.Response, error)

	/*
		GetGroupMetricsByDevices GetByCountries Click Metrics for a Group by Device Type

		Returns the device types generating click traffic to the specified group's links.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetGroupMetricsByDevicesRequest
	*/
	GetGroupMetricsByDevices(ctx _context.Context, groupGuid string) ApiGetGroupMetricsByDevicesRequest

	// GetGroupMetricsByDevicesExecute executes the request
	//  @return DeviceMetrics
	GetGroupMetricsByDevicesExecute(r ApiGetGroupMetricsByDevicesRequest) (DeviceMetrics, *_nethttp.Response, error)

	/*
		GetGroupMetricsByReferringNetworks GetByCountries Click Metrics for a Group by Referring Networks

		Returns metrics by referring networks for the specified group's links.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetGroupMetricsByReferringNetworksRequest
	*/
	GetGroupMetricsByReferringNetworks(ctx _context.Context, groupGuid string) ApiGetGroupMetricsByReferringNetworksRequest

	// GetGroupMetricsByReferringNetworksExecute executes the request
	//  @return ClickMetrics
	GetGroupMetricsByReferringNetworksExecute(r ApiGetGroupMetricsByReferringNetworksRequest) (ClickMetrics, *_nethttp.Response, error)

	/*
		GetGroupPreferences Retrieve Group Preferences

		Returns preferences for the specified group.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetGroupPreferencesRequest
	*/
	GetGroupPreferences(ctx _context.Context, groupGuid string) ApiGetGroupPreferencesRequest

	// GetGroupPreferencesExecute executes the request
	//  @return GroupPreferences
	GetGroupPreferencesExecute(r ApiGetGroupPreferencesRequest) (GroupPreferences, *_nethttp.Response, error)

	/*
		GetGroupShortenCounts Retrieve Group Shorten Counts

		Returns all the shorten counts for a group.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetGroupShortenCountsRequest
	*/
	GetGroupShortenCounts(ctx _context.Context, groupGuid string) ApiGetGroupShortenCountsRequest

	// GetGroupShortenCountsExecute executes the request
	//  @return Metrics
	GetGroupShortenCountsExecute(r ApiGetGroupShortenCountsRequest) (Metrics, *_nethttp.Response, error)

	/*
		GetGroupTags Retrieve Tags by Group

		Returns the tags currently used in the specified group. Maximum 1000.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetGroupTagsRequest
	*/
	GetGroupTags(ctx _context.Context, groupGuid string) ApiGetGroupTagsRequest

	// GetGroupTagsExecute executes the request
	//  @return Tags
	GetGroupTagsExecute(r ApiGetGroupTagsRequest) (Tags, *_nethttp.Response, error)

	/*
		GetGroups Retrieve Groups

		Returns a list of groups in the organization.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiGetGroupsRequest
	*/
	GetGroups(ctx _context.Context) ApiGetGroupsRequest

	// GetGroupsExecute executes the request
	//  @return Groups
	GetGroupsExecute(r ApiGetGroupsRequest) (Groups, *_nethttp.Response, error)

	/*
		UpdateGroup Update a Group

		Updates the details of a group.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiUpdateGroupRequest
	*/
	UpdateGroup(ctx _context.Context, groupGuid string) ApiUpdateGroupRequest

	// UpdateGroupExecute executes the request
	//  @return Group
	UpdateGroupExecute(r ApiUpdateGroupRequest) (Group, *_nethttp.Response, error)

	/*
		UpdateGroupPreferences Update Group Preferences

		Updates preferences for a group.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiUpdateGroupPreferencesRequest
	*/
	UpdateGroupPreferences(ctx _context.Context, groupGuid string) ApiUpdateGroupPreferencesRequest

	// UpdateGroupPreferencesExecute executes the request
	//  @return GroupPreferences
	UpdateGroupPreferencesExecute(r ApiUpdateGroupPreferencesRequest) (GroupPreferences, *_nethttp.Response, error)
}

// GroupsApiService GroupsApi service
type GroupsApiService service

type ApiGetGroupRequest struct {
	ctx        _context.Context
	ApiService GroupsApi
	groupGuid  string
}

func (r ApiGetGroupRequest) Execute() (Group, *_nethttp.Response, error) {
	return r.ApiService.GetGroupExecute(r)
}

/*
GetGroup Retrieve a Group

Returns details for a group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetGroupRequest
*/
func (a *GroupsApiService) GetGroup(ctx _context.Context, groupGuid string) ApiGetGroupRequest {
	return ApiGetGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return Group
func (a *GroupsApiService) GetGroupExecute(r ApiGetGroupRequest) (Group, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupClicksRequest struct {
	ctx           _context.Context
	ApiService    GroupsApi
	groupGuid     string
	unit          *TimeUnit
	units         *int32
	unitReference *string
}

// A unit of time
func (r ApiGetGroupClicksRequest) Unit(unit TimeUnit) ApiGetGroupClicksRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetGroupClicksRequest) Units(units int32) ApiGetGroupClicksRequest {
	r.units = &units
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetGroupClicksRequest) UnitReference(unitReference string) ApiGetGroupClicksRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetGroupClicksRequest) Execute() (GroupClicks, *_nethttp.Response, error) {
	return r.ApiService.GetGroupClicksExecute(r)
}

/*
GetGroupClicks GetByCountries clicks by group

get number of clicks on bitlinks in a group

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetGroupClicksRequest
*/
func (a *GroupsApiService) GetGroupClicks(ctx _context.Context, groupGuid string) ApiGetGroupClicksRequest {
	return ApiGetGroupClicksRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return GroupClicks
func (a *GroupsApiService) GetGroupClicksExecute(r ApiGetGroupClicksRequest) (GroupClicks, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GroupClicks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroupClicks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/clicks"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v UpgradeRequired
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupMetricsByCitiesRequest struct {
	ctx           _context.Context
	ApiService    GroupsApi
	groupGuid     string
	unit          *TimeUnit
	units         *int32
	size          *int32
	unitReference *string
}

// A unit of time
func (r ApiGetGroupMetricsByCitiesRequest) Unit(unit TimeUnit) ApiGetGroupMetricsByCitiesRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetGroupMetricsByCitiesRequest) Units(units int32) ApiGetGroupMetricsByCitiesRequest {
	r.units = &units
	return r
}

// The quantity of items to be be returned
func (r ApiGetGroupMetricsByCitiesRequest) Size(size int32) ApiGetGroupMetricsByCitiesRequest {
	r.size = &size
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetGroupMetricsByCitiesRequest) UnitReference(unitReference string) ApiGetGroupMetricsByCitiesRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetGroupMetricsByCitiesRequest) Execute() (CityMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetGroupMetricsByCitiesExecute(r)
}

/*
GetGroupMetricsByCities GetByCountries Click Metrics for a Group by City

Returns the geographic origins of click traffic by city for the specified group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetGroupMetricsByCitiesRequest
*/
func (a *GroupsApiService) GetGroupMetricsByCities(ctx _context.Context, groupGuid string) ApiGetGroupMetricsByCitiesRequest {
	return ApiGetGroupMetricsByCitiesRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return CityMetrics
func (a *GroupsApiService) GetGroupMetricsByCitiesExecute(r ApiGetGroupMetricsByCitiesRequest) (CityMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CityMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroupMetricsByCities")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/cities"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v UpgradeRequired
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupMetricsByCountriesRequest struct {
	ctx           _context.Context
	ApiService    GroupsApi
	groupGuid     string
	unit          *TimeUnit
	units         *int32
	size          *int32
	unitReference *string
}

// A unit of time
func (r ApiGetGroupMetricsByCountriesRequest) Unit(unit TimeUnit) ApiGetGroupMetricsByCountriesRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetGroupMetricsByCountriesRequest) Units(units int32) ApiGetGroupMetricsByCountriesRequest {
	r.units = &units
	return r
}

// The quantity of items to be be returned
func (r ApiGetGroupMetricsByCountriesRequest) Size(size int32) ApiGetGroupMetricsByCountriesRequest {
	r.size = &size
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetGroupMetricsByCountriesRequest) UnitReference(unitReference string) ApiGetGroupMetricsByCountriesRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetGroupMetricsByCountriesRequest) Execute() (ClickMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetGroupMetricsByCountriesExecute(r)
}

/*
GetGroupMetricsByCountries GetByCountries Click Metrics for a Group by Country

Returns the geographic origins of click traffic by country for the specified group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetGroupMetricsByCountriesRequest
*/
func (a *GroupsApiService) GetGroupMetricsByCountries(ctx _context.Context, groupGuid string) ApiGetGroupMetricsByCountriesRequest {
	return ApiGetGroupMetricsByCountriesRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return ClickMetrics
func (a *GroupsApiService) GetGroupMetricsByCountriesExecute(r ApiGetGroupMetricsByCountriesRequest) (ClickMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClickMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroupMetricsByCountries")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/countries"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupMetricsByDevicesRequest struct {
	ctx           _context.Context
	ApiService    GroupsApi
	groupGuid     string
	unit          *TimeUnit
	units         *int32
	size          *int32
	unitReference *string
}

// A unit of time
func (r ApiGetGroupMetricsByDevicesRequest) Unit(unit TimeUnit) ApiGetGroupMetricsByDevicesRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetGroupMetricsByDevicesRequest) Units(units int32) ApiGetGroupMetricsByDevicesRequest {
	r.units = &units
	return r
}

// The quantity of items to be be returned
func (r ApiGetGroupMetricsByDevicesRequest) Size(size int32) ApiGetGroupMetricsByDevicesRequest {
	r.size = &size
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetGroupMetricsByDevicesRequest) UnitReference(unitReference string) ApiGetGroupMetricsByDevicesRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetGroupMetricsByDevicesRequest) Execute() (DeviceMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetGroupMetricsByDevicesExecute(r)
}

/*
GetGroupMetricsByDevices GetByCountries Click Metrics for a Group by Device Type

Returns the device types generating click traffic to the specified group's links.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetGroupMetricsByDevicesRequest
*/
func (a *GroupsApiService) GetGroupMetricsByDevices(ctx _context.Context, groupGuid string) ApiGetGroupMetricsByDevicesRequest {
	return ApiGetGroupMetricsByDevicesRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return DeviceMetrics
func (a *GroupsApiService) GetGroupMetricsByDevicesExecute(r ApiGetGroupMetricsByDevicesRequest) (DeviceMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeviceMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroupMetricsByDevices")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v UpgradeRequired
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupMetricsByReferringNetworksRequest struct {
	ctx        _context.Context
	ApiService GroupsApi
	groupGuid  string
}

func (r ApiGetGroupMetricsByReferringNetworksRequest) Execute() (ClickMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetGroupMetricsByReferringNetworksExecute(r)
}

/*
GetGroupMetricsByReferringNetworks GetByCountries Click Metrics for a Group by Referring Networks

Returns metrics by referring networks for the specified group's links.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetGroupMetricsByReferringNetworksRequest
*/
func (a *GroupsApiService) GetGroupMetricsByReferringNetworks(ctx _context.Context, groupGuid string) ApiGetGroupMetricsByReferringNetworksRequest {
	return ApiGetGroupMetricsByReferringNetworksRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return ClickMetrics
func (a *GroupsApiService) GetGroupMetricsByReferringNetworksExecute(r ApiGetGroupMetricsByReferringNetworksRequest) (ClickMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClickMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroupMetricsByReferringNetworks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/referring_networks"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupPreferencesRequest struct {
	ctx        _context.Context
	ApiService GroupsApi
	groupGuid  string
}

func (r ApiGetGroupPreferencesRequest) Execute() (GroupPreferences, *_nethttp.Response, error) {
	return r.ApiService.GetGroupPreferencesExecute(r)
}

/*
GetGroupPreferences Retrieve Group Preferences

Returns preferences for the specified group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetGroupPreferencesRequest
*/
func (a *GroupsApiService) GetGroupPreferences(ctx _context.Context, groupGuid string) ApiGetGroupPreferencesRequest {
	return ApiGetGroupPreferencesRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return GroupPreferences
func (a *GroupsApiService) GetGroupPreferencesExecute(r ApiGetGroupPreferencesRequest) (GroupPreferences, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GroupPreferences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroupPreferences")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupShortenCountsRequest struct {
	ctx           _context.Context
	ApiService    GroupsApi
	groupGuid     string
	unit          *TimeUnit
	units         *int32
	unitReference *string
}

// A unit of time
func (r ApiGetGroupShortenCountsRequest) Unit(unit TimeUnit) ApiGetGroupShortenCountsRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetGroupShortenCountsRequest) Units(units int32) ApiGetGroupShortenCountsRequest {
	r.units = &units
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetGroupShortenCountsRequest) UnitReference(unitReference string) ApiGetGroupShortenCountsRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetGroupShortenCountsRequest) Execute() (Metrics, *_nethttp.Response, error) {
	return r.ApiService.GetGroupShortenCountsExecute(r)
}

/*
GetGroupShortenCounts Retrieve Group Shorten Counts

Returns all the shorten counts for a group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetGroupShortenCountsRequest
*/
func (a *GroupsApiService) GetGroupShortenCounts(ctx _context.Context, groupGuid string) ApiGetGroupShortenCountsRequest {
	return ApiGetGroupShortenCountsRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return Metrics
func (a *GroupsApiService) GetGroupShortenCountsExecute(r ApiGetGroupShortenCountsRequest) (Metrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Metrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroupShortenCounts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/shorten_counts"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupTagsRequest struct {
	ctx        _context.Context
	ApiService GroupsApi
	groupGuid  string
}

func (r ApiGetGroupTagsRequest) Execute() (Tags, *_nethttp.Response, error) {
	return r.ApiService.GetGroupTagsExecute(r)
}

/*
GetGroupTags Retrieve Tags by Group

Returns the tags currently used in the specified group. Maximum 1000.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetGroupTagsRequest
*/
func (a *GroupsApiService) GetGroupTags(ctx _context.Context, groupGuid string) ApiGetGroupTagsRequest {
	return ApiGetGroupTagsRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return Tags
func (a *GroupsApiService) GetGroupTagsExecute(r ApiGetGroupTagsRequest) (Tags, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Tags
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroupTags")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGroupsRequest struct {
	ctx              _context.Context
	ApiService       GroupsApi
	organizationGuid *string
}

// A GUID for a Bitly organization
func (r ApiGetGroupsRequest) OrganizationGuid(organizationGuid string) ApiGetGroupsRequest {
	r.organizationGuid = &organizationGuid
	return r
}

func (r ApiGetGroupsRequest) Execute() (Groups, *_nethttp.Response, error) {
	return r.ApiService.GetGroupsExecute(r)
}

/*
GetGroups Retrieve Groups

Returns a list of groups in the organization.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGroupsRequest
*/
func (a *GroupsApiService) GetGroups(ctx _context.Context) ApiGetGroupsRequest {
	return ApiGetGroupsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Groups
func (a *GroupsApiService) GetGroupsExecute(r ApiGetGroupsRequest) (Groups, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Groups
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.GetGroups")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.organizationGuid != nil {
		localVarQueryParams.Add("organization_guid", parameterToString(*r.organizationGuid, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v UnprocessableEntity
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGroupRequest struct {
	ctx         _context.Context
	ApiService  GroupsApi
	groupGuid   string
	groupUpdate *GroupUpdate
}

func (r ApiUpdateGroupRequest) GroupUpdate(groupUpdate GroupUpdate) ApiUpdateGroupRequest {
	r.groupUpdate = &groupUpdate
	return r
}

func (r ApiUpdateGroupRequest) Execute() (Group, *_nethttp.Response, error) {
	return r.ApiService.UpdateGroupExecute(r)
}

/*
UpdateGroup Update a Group

Updates the details of a group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiUpdateGroupRequest
*/
func (a *GroupsApiService) UpdateGroup(ctx _context.Context, groupGuid string) ApiUpdateGroupRequest {
	return ApiUpdateGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return Group
func (a *GroupsApiService) UpdateGroupExecute(r ApiUpdateGroupRequest) (Group, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.UpdateGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.groupUpdate == nil {
		return localVarReturnValue, nil, reportError("groupUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v UnprocessableEntity
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGroupPreferencesRequest struct {
	ctx              _context.Context
	ApiService       GroupsApi
	groupGuid        string
	groupPreferences *GroupPreferences
}

func (r ApiUpdateGroupPreferencesRequest) GroupPreferences(groupPreferences GroupPreferences) ApiUpdateGroupPreferencesRequest {
	r.groupPreferences = &groupPreferences
	return r
}

func (r ApiUpdateGroupPreferencesRequest) Execute() (GroupPreferences, *_nethttp.Response, error) {
	return r.ApiService.UpdateGroupPreferencesExecute(r)
}

/*
UpdateGroupPreferences Update Group Preferences

Updates preferences for a group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiUpdateGroupPreferencesRequest
*/
func (a *GroupsApiService) UpdateGroupPreferences(ctx _context.Context, groupGuid string) ApiUpdateGroupPreferencesRequest {
	return ApiUpdateGroupPreferencesRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return GroupPreferences
func (a *GroupsApiService) UpdateGroupPreferencesExecute(r ApiUpdateGroupPreferencesRequest) (GroupPreferences, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GroupPreferences
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "GroupsApiService.UpdateGroupPreferences")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.groupPreferences == nil {
		return localVarReturnValue, nil, reportError("groupPreferences is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.groupPreferences
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v UnprocessableEntity
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
