/*
Bitly API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 4.0.0
Contact: api@bitly.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	"fmt"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"reflect"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type BitlinksApi interface {

	/*
		CreateBitlink Shorten a Link

		Converts a long url to a Bitlink.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiCreateBitlinkRequest
	*/
	CreateBitlink(ctx _context.Context) ApiCreateBitlinkRequest

	// CreateBitlinkExecute executes the request
	//  @return ShortenBitlinkBody
	CreateBitlinkExecute(r ApiCreateBitlinkRequest) (ShortenBitlinkBody, *_nethttp.Response, error)

	/*
		CreateFullBitlink Create a Bitlink

		Converts a long url to a Bitlink and sets additional parameters.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiCreateFullBitlinkRequest
	*/
	CreateFullBitlink(ctx _context.Context) ApiCreateFullBitlinkRequest

	// CreateFullBitlinkExecute executes the request
	//  @return BitlinkBody
	CreateFullBitlinkExecute(r ApiCreateFullBitlinkRequest) (BitlinkBody, *_nethttp.Response, error)

	/*
		ExpandBitlink Expand a Bitlink

		Returns the short link and long URL for the specified link.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @return ApiExpandBitlinkRequest
	*/
	ExpandBitlink(ctx _context.Context) ApiExpandBitlinkRequest

	// ExpandBitlinkExecute executes the request
	//  @return ExpandedBitlink
	ExpandBitlinkExecute(r ApiExpandBitlinkRequest) (ExpandedBitlink, *_nethttp.Response, error)

	/*
		GetBitlink Retrieve a Bitlink

		Returns information for the specified link.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetBitlinkRequest
	*/
	GetBitlink(ctx _context.Context, bitlink string) ApiGetBitlinkRequest

	// GetBitlinkExecute executes the request
	//  @return BitlinkBody
	GetBitlinkExecute(r ApiGetBitlinkRequest) (BitlinkBody, *_nethttp.Response, error)

	/*
		GetBitlinkQRCode GetByCountries a QR Code

		Generates a QR code for a Bitlink.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetBitlinkQRCodeRequest
	*/
	GetBitlinkQRCode(ctx _context.Context, bitlink string) ApiGetBitlinkQRCodeRequest

	// GetBitlinkQRCodeExecute executes the request
	//  @return BitlinkQR
	GetBitlinkQRCodeExecute(r ApiGetBitlinkQRCodeRequest) (BitlinkQR, *_nethttp.Response, error)

	/*
		GetBitlinksByGroup Retrieve Bitlinks by Group

		Returns a paginated collection of Bitlinks for a group.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiGetBitlinksByGroupRequest
	*/
	GetBitlinksByGroup(ctx _context.Context, groupGuid string) ApiGetBitlinksByGroupRequest

	// GetBitlinksByGroupExecute executes the request
	//  @return Bitlinks
	GetBitlinksByGroupExecute(r ApiGetBitlinksByGroupRequest) (Bitlinks, *_nethttp.Response, error)

	/*
		GetClicksForBitlink GetByCountries Clicks for a Bitlink

		Returns the click counts for the specified link in an array based on a date.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetClicksForBitlinkRequest
	*/
	GetClicksForBitlink(ctx _context.Context, bitlink string) ApiGetClicksForBitlinkRequest

	// GetClicksForBitlinkExecute executes the request
	//  @return Clicks
	GetClicksForBitlinkExecute(r ApiGetClicksForBitlinkRequest) (Clicks, *_nethttp.Response, error)

	/*
		GetClicksSummaryForBitlink GetByCountries a Clicks Summary for a Bitlink

		Returns the click counts for the specified link rolled up into a single field.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetClicksSummaryForBitlinkRequest
	*/
	GetClicksSummaryForBitlink(ctx _context.Context, bitlink string) ApiGetClicksSummaryForBitlinkRequest

	// GetClicksSummaryForBitlinkExecute executes the request
	//  @return ClicksSummary
	GetClicksSummaryForBitlinkExecute(r ApiGetClicksSummaryForBitlinkRequest) (ClicksSummary, *_nethttp.Response, error)

	/*
		GetMetricsForBitlinkByCities GetByCountries Metrics for a Bitlink by City

		Returns the city origins of click traffic for the specified link.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetMetricsForBitlinkByCitiesRequest
	*/
	GetMetricsForBitlinkByCities(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByCitiesRequest

	// GetMetricsForBitlinkByCitiesExecute executes the request
	//  @return CityMetrics
	GetMetricsForBitlinkByCitiesExecute(r ApiGetMetricsForBitlinkByCitiesRequest) (CityMetrics, *_nethttp.Response, error)

	/*
		GetMetricsForBitlinkByCountries GetByCountries Metrics for a Bitlink by Country

		Returns the country origins of click traffic for the specified link.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetMetricsForBitlinkByCountriesRequest
	*/
	GetMetricsForBitlinkByCountries(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByCountriesRequest

	// GetMetricsForBitlinkByCountriesExecute executes the request
	//  @return ClickMetrics
	GetMetricsForBitlinkByCountriesExecute(r ApiGetMetricsForBitlinkByCountriesRequest) (ClickMetrics, *_nethttp.Response, error)

	/*
		GetMetricsForBitlinkByDevices GetByCountries Metrics for a Bitlink by Device Type

		Returns the device types generating click traffic to the specified link.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetMetricsForBitlinkByDevicesRequest
	*/
	GetMetricsForBitlinkByDevices(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByDevicesRequest

	// GetMetricsForBitlinkByDevicesExecute executes the request
	//  @return DeviceMetrics
	GetMetricsForBitlinkByDevicesExecute(r ApiGetMetricsForBitlinkByDevicesRequest) (DeviceMetrics, *_nethttp.Response, error)

	/*
		GetMetricsForBitlinkByReferrers GetByCountries Metrics for a Bitlink by Referrers

		Returns referrer click counts for the specified link.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetMetricsForBitlinkByReferrersRequest
	*/
	GetMetricsForBitlinkByReferrers(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByReferrersRequest

	// GetMetricsForBitlinkByReferrersExecute executes the request
	//  @return ClickMetrics
	GetMetricsForBitlinkByReferrersExecute(r ApiGetMetricsForBitlinkByReferrersRequest) (ClickMetrics, *_nethttp.Response, error)

	/*
		GetMetricsForBitlinkByReferrersByDomains GetByCountries Metrics for a Bitlink by Referrers by Domain

		Returns click metrics grouped by referrers for the specified link.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetMetricsForBitlinkByReferrersByDomainsRequest
	*/
	GetMetricsForBitlinkByReferrersByDomains(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByReferrersByDomainsRequest

	// GetMetricsForBitlinkByReferrersByDomainsExecute executes the request
	//  @return ReferrersByDomains
	GetMetricsForBitlinkByReferrersByDomainsExecute(r ApiGetMetricsForBitlinkByReferrersByDomainsRequest) (ReferrersByDomains, *_nethttp.Response, error)

	/*
		GetMetricsForBitlinkByReferringDomains GetByCountries Metrics for a Bitlink by Referring Domains

		Returns the referring domain click counts for the specified link.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiGetMetricsForBitlinkByReferringDomainsRequest
	*/
	GetMetricsForBitlinkByReferringDomains(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByReferringDomainsRequest

	// GetMetricsForBitlinkByReferringDomainsExecute executes the request
	//  @return ClickMetrics
	GetMetricsForBitlinkByReferringDomainsExecute(r ApiGetMetricsForBitlinkByReferringDomainsRequest) (ClickMetrics, *_nethttp.Response, error)

	/*
		GetSortedBitlinks Retrieve Sorted Bitlinks for Group

		Returns a list of Bitlinks sorted by group.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @param sort The type of sorting that you would like to do
		 @return ApiGetSortedBitlinksRequest
	*/
	GetSortedBitlinks(ctx _context.Context, groupGuid string, sort string) ApiGetSortedBitlinksRequest

	// GetSortedBitlinksExecute executes the request
	//  @return SortedLinks
	GetSortedBitlinksExecute(r ApiGetSortedBitlinksRequest) (SortedLinks, *_nethttp.Response, error)

	/*
		UpdateBitlink Update a Bitlink

		Updates fields in the specified link.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param bitlink A Bitlink made of the domain and hash
		 @return ApiUpdateBitlinkRequest
	*/
	UpdateBitlink(ctx _context.Context, bitlink string) ApiUpdateBitlinkRequest

	// UpdateBitlinkExecute executes the request
	//  @return BitlinkBody
	UpdateBitlinkExecute(r ApiUpdateBitlinkRequest) (BitlinkBody, *_nethttp.Response, error)

	/*
		UpdateBitlinksByGroup Bulk update bitlinks

		Bulk update can add or remove tags or archive up to 100 links at a time; The response includes a a list of bitlink ids that were updated.

		 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		 @param groupGuid A GUID for a Bitly group
		 @return ApiUpdateBitlinksByGroupRequest
	*/
	UpdateBitlinksByGroup(ctx _context.Context, groupGuid string) ApiUpdateBitlinksByGroupRequest

	// UpdateBitlinksByGroupExecute executes the request
	//  @return BulkUpdate
	UpdateBitlinksByGroupExecute(r ApiUpdateBitlinksByGroupRequest) (BulkUpdate, *_nethttp.Response, error)
}

// BitlinksApiService BitlinksApi service
type BitlinksApiService service

type ApiCreateBitlinkRequest struct {
	ctx        _context.Context
	ApiService BitlinksApi
	shorten    *Shorten
}

func (r ApiCreateBitlinkRequest) Shorten(shorten Shorten) ApiCreateBitlinkRequest {
	r.shorten = &shorten
	return r
}

func (r ApiCreateBitlinkRequest) Execute() (ShortenBitlinkBody, *_nethttp.Response, error) {
	return r.ApiService.CreateBitlinkExecute(r)
}

/*
CreateBitlink Shorten a Link

Converts a long url to a Bitlink.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBitlinkRequest
*/
func (a *BitlinksApiService) CreateBitlink(ctx _context.Context) ApiCreateBitlinkRequest {
	return ApiCreateBitlinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ShortenBitlinkBody
func (a *BitlinksApiService) CreateBitlinkExecute(r ApiCreateBitlinkRequest) (ShortenBitlinkBody, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ShortenBitlinkBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.CreateBitlink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shorten"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.shorten == nil {
		return localVarReturnValue, nil, reportError("shorten is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.shorten
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v ExpectationFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v UnprocessableEntity
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFullBitlinkRequest struct {
	ctx         _context.Context
	ApiService  BitlinksApi
	fullShorten *FullShorten
}

func (r ApiCreateFullBitlinkRequest) FullShorten(fullShorten FullShorten) ApiCreateFullBitlinkRequest {
	r.fullShorten = &fullShorten
	return r
}

func (r ApiCreateFullBitlinkRequest) Execute() (BitlinkBody, *_nethttp.Response, error) {
	return r.ApiService.CreateFullBitlinkExecute(r)
}

/*
CreateFullBitlink Create a Bitlink

Converts a long url to a Bitlink and sets additional parameters.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFullBitlinkRequest
*/
func (a *BitlinksApiService) CreateFullBitlink(ctx _context.Context) ApiCreateFullBitlinkRequest {
	return ApiCreateFullBitlinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BitlinkBody
func (a *BitlinksApiService) CreateFullBitlinkExecute(r ApiCreateFullBitlinkRequest) (BitlinkBody, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BitlinkBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.CreateFullBitlink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fullShorten == nil {
		return localVarReturnValue, nil, reportError("fullShorten is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fullShorten
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 417 {
			var v ExpectationFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v UnprocessableEntity
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v UpgradeRequired
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExpandBitlinkRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	expandBitlink *ExpandBitlink
}

func (r ApiExpandBitlinkRequest) ExpandBitlink(expandBitlink ExpandBitlink) ApiExpandBitlinkRequest {
	r.expandBitlink = &expandBitlink
	return r
}

func (r ApiExpandBitlinkRequest) Execute() (ExpandedBitlink, *_nethttp.Response, error) {
	return r.ApiService.ExpandBitlinkExecute(r)
}

/*
ExpandBitlink Expand a Bitlink

Returns the short link and long URL for the specified link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiExpandBitlinkRequest
*/
func (a *BitlinksApiService) ExpandBitlink(ctx _context.Context) ApiExpandBitlinkRequest {
	return ApiExpandBitlinkRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return ExpandedBitlink
func (a *BitlinksApiService) ExpandBitlinkExecute(r ApiExpandBitlinkRequest) (ExpandedBitlink, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ExpandedBitlink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.ExpandBitlink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/expand"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.expandBitlink == nil {
		return localVarReturnValue, nil, reportError("expandBitlink is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.expandBitlink
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v UnprocessableEntity
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBitlinkRequest struct {
	ctx        _context.Context
	ApiService BitlinksApi
	bitlink    string
}

func (r ApiGetBitlinkRequest) Execute() (BitlinkBody, *_nethttp.Response, error) {
	return r.ApiService.GetBitlinkExecute(r)
}

/*
GetBitlink Retrieve a Bitlink

Returns information for the specified link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetBitlinkRequest
*/
func (a *BitlinksApiService) GetBitlink(ctx _context.Context, bitlink string) ApiGetBitlinkRequest {
	return ApiGetBitlinkRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return BitlinkBody
func (a *BitlinksApiService) GetBitlinkExecute(r ApiGetBitlinkRequest) (BitlinkBody, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BitlinkBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetBitlink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBitlinkQRCodeRequest struct {
	ctx              _context.Context
	ApiService       BitlinksApi
	bitlink          string
	color            *string
	excludeBitlyLogo *bool
	imageFormat      *string
}

// A color denoted in hexidecimal RGB format
func (r ApiGetBitlinkQRCodeRequest) Color(color string) ApiGetBitlinkQRCodeRequest {
	r.color = &color
	return r
}

// Removes the Bitly logo from the center of the generated QR image
func (r ApiGetBitlinkQRCodeRequest) ExcludeBitlyLogo(excludeBitlyLogo bool) ApiGetBitlinkQRCodeRequest {
	r.excludeBitlyLogo = &excludeBitlyLogo
	return r
}

// Determines the image format of the returned QR code
func (r ApiGetBitlinkQRCodeRequest) ImageFormat(imageFormat string) ApiGetBitlinkQRCodeRequest {
	r.imageFormat = &imageFormat
	return r
}

func (r ApiGetBitlinkQRCodeRequest) Execute() (BitlinkQR, *_nethttp.Response, error) {
	return r.ApiService.GetBitlinkQRCodeExecute(r)
}

/*
GetBitlinkQRCode GetByCountries a QR Code

Generates a QR code for a Bitlink.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetBitlinkQRCodeRequest
*/
func (a *BitlinksApiService) GetBitlinkQRCode(ctx _context.Context, bitlink string) ApiGetBitlinkQRCodeRequest {
	return ApiGetBitlinkQRCodeRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return BitlinkQR
func (a *BitlinksApiService) GetBitlinkQRCodeExecute(r ApiGetBitlinkQRCodeRequest) (BitlinkQR, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BitlinkQR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetBitlinkQRCode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}/qr"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.color != nil {
		localVarQueryParams.Add("color", parameterToString(*r.color, ""))
	}
	if r.excludeBitlyLogo != nil {
		localVarQueryParams.Add("exclude_bitly_logo", parameterToString(*r.excludeBitlyLogo, ""))
	}
	if r.imageFormat != nil {
		localVarQueryParams.Add("image_format", parameterToString(*r.imageFormat, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v UpgradeRequired
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBitlinksByGroupRequest struct {
	ctx             _context.Context
	ApiService      BitlinksApi
	groupGuid       string
	size            *int32
	page            *int32
	keyword         *string
	query           *string
	createdBefore   *int32
	createdAfter    *int32
	modifiedAfter   *int32
	archived        *string
	deeplinks       *string
	domainDeeplinks *string
	campaignGuid    *string
	channelGuid     *string
	customBitlink   *string
	tags            *[]string
	launchpadIds    *[]string
	encodingLogin   *[]string
}

// The quantity of items to be be returned
func (r ApiGetBitlinksByGroupRequest) Size(size int32) ApiGetBitlinksByGroupRequest {
	r.size = &size
	return r
}

// Integer specifying the numbered result at which to start
func (r ApiGetBitlinksByGroupRequest) Page(page int32) ApiGetBitlinksByGroupRequest {
	r.page = &page
	return r
}

// Custom keyword to filter on history entries
func (r ApiGetBitlinksByGroupRequest) Keyword(keyword string) ApiGetBitlinksByGroupRequest {
	r.keyword = &keyword
	return r
}

// the value that you would like to search
func (r ApiGetBitlinksByGroupRequest) Query(query string) ApiGetBitlinksByGroupRequest {
	r.query = &query
	return r
}

// Timestamp as an integer unix epoch
func (r ApiGetBitlinksByGroupRequest) CreatedBefore(createdBefore int32) ApiGetBitlinksByGroupRequest {
	r.createdBefore = &createdBefore
	return r
}

// Timestamp as an integer unix epoch
func (r ApiGetBitlinksByGroupRequest) CreatedAfter(createdAfter int32) ApiGetBitlinksByGroupRequest {
	r.createdAfter = &createdAfter
	return r
}

// Timestamp as an integer unix epoch
func (r ApiGetBitlinksByGroupRequest) ModifiedAfter(modifiedAfter int32) ApiGetBitlinksByGroupRequest {
	r.modifiedAfter = &modifiedAfter
	return r
}

// Whether or not to include archived bitlinks
func (r ApiGetBitlinksByGroupRequest) Archived(archived string) ApiGetBitlinksByGroupRequest {
	r.archived = &archived
	return r
}

// Filter to only Bitlinks that contain deeplinks
func (r ApiGetBitlinksByGroupRequest) Deeplinks(deeplinks string) ApiGetBitlinksByGroupRequest {
	r.deeplinks = &deeplinks
	return r
}

// Filter to only Bitlinks that contain deeplinks configured with a custom domain
func (r ApiGetBitlinksByGroupRequest) DomainDeeplinks(domainDeeplinks string) ApiGetBitlinksByGroupRequest {
	r.domainDeeplinks = &domainDeeplinks
	return r
}

// Filter to return only links for the given campaign GUID, can be provided
func (r ApiGetBitlinksByGroupRequest) CampaignGuid(campaignGuid string) ApiGetBitlinksByGroupRequest {
	r.campaignGuid = &campaignGuid
	return r
}

// Filter to return only links for the given channel GUID, can be provided, overrides all other parameters
func (r ApiGetBitlinksByGroupRequest) ChannelGuid(channelGuid string) ApiGetBitlinksByGroupRequest {
	r.channelGuid = &channelGuid
	return r
}
func (r ApiGetBitlinksByGroupRequest) CustomBitlink(customBitlink string) ApiGetBitlinksByGroupRequest {
	r.customBitlink = &customBitlink
	return r
}

// filter by given tags
func (r ApiGetBitlinksByGroupRequest) Tags(tags []string) ApiGetBitlinksByGroupRequest {
	r.tags = &tags
	return r
}

// filter by launchpad id
func (r ApiGetBitlinksByGroupRequest) LaunchpadIds(launchpadIds []string) ApiGetBitlinksByGroupRequest {
	r.launchpadIds = &launchpadIds
	return r
}

// Filter by the login of the authenticated user that created the Bitlink
func (r ApiGetBitlinksByGroupRequest) EncodingLogin(encodingLogin []string) ApiGetBitlinksByGroupRequest {
	r.encodingLogin = &encodingLogin
	return r
}

func (r ApiGetBitlinksByGroupRequest) Execute() (Bitlinks, *_nethttp.Response, error) {
	return r.ApiService.GetBitlinksByGroupExecute(r)
}

/*
GetBitlinksByGroup Retrieve Bitlinks by Group

Returns a paginated collection of Bitlinks for a group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiGetBitlinksByGroupRequest
*/
func (a *BitlinksApiService) GetBitlinksByGroup(ctx _context.Context, groupGuid string) ApiGetBitlinksByGroupRequest {
	return ApiGetBitlinksByGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return Bitlinks
func (a *BitlinksApiService) GetBitlinksByGroupExecute(r ApiGetBitlinksByGroupRequest) (Bitlinks, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Bitlinks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetBitlinksByGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/bitlinks"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.keyword != nil {
		localVarQueryParams.Add("keyword", parameterToString(*r.keyword, ""))
	}
	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.createdBefore != nil {
		localVarQueryParams.Add("created_before", parameterToString(*r.createdBefore, ""))
	}
	if r.createdAfter != nil {
		localVarQueryParams.Add("created_after", parameterToString(*r.createdAfter, ""))
	}
	if r.modifiedAfter != nil {
		localVarQueryParams.Add("modified_after", parameterToString(*r.modifiedAfter, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.deeplinks != nil {
		localVarQueryParams.Add("deeplinks", parameterToString(*r.deeplinks, ""))
	}
	if r.domainDeeplinks != nil {
		localVarQueryParams.Add("domain_deeplinks", parameterToString(*r.domainDeeplinks, ""))
	}
	if r.campaignGuid != nil {
		localVarQueryParams.Add("campaign_guid", parameterToString(*r.campaignGuid, ""))
	}
	if r.channelGuid != nil {
		localVarQueryParams.Add("channel_guid", parameterToString(*r.channelGuid, ""))
	}
	if r.customBitlink != nil {
		localVarQueryParams.Add("custom_bitlink", parameterToString(*r.customBitlink, ""))
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("tags", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("tags", parameterToString(t, "multi"))
		}
	}
	if r.launchpadIds != nil {
		t := *r.launchpadIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("launchpad_ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("launchpad_ids", parameterToString(t, "multi"))
		}
	}
	if r.encodingLogin != nil {
		t := *r.encodingLogin
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("encoding_login", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("encoding_login", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		fmt.Println("err...", err.Error())
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClicksForBitlinkRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	bitlink       string
	unit          *TimeUnit
	units         *int32
	unitReference *string
}

// A unit of time
func (r ApiGetClicksForBitlinkRequest) Unit(unit TimeUnit) ApiGetClicksForBitlinkRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetClicksForBitlinkRequest) Units(units int32) ApiGetClicksForBitlinkRequest {
	r.units = &units
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetClicksForBitlinkRequest) UnitReference(unitReference string) ApiGetClicksForBitlinkRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetClicksForBitlinkRequest) Execute() (Clicks, *_nethttp.Response, error) {
	return r.ApiService.GetClicksForBitlinkExecute(r)
}

/*
GetClicksForBitlink GetByCountries Clicks for a Bitlink

Returns the click counts for the specified link in an array based on a date.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetClicksForBitlinkRequest
*/
func (a *BitlinksApiService) GetClicksForBitlink(ctx _context.Context, bitlink string) ApiGetClicksForBitlinkRequest {
	return ApiGetClicksForBitlinkRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return Clicks
func (a *BitlinksApiService) GetClicksForBitlinkExecute(r ApiGetClicksForBitlinkRequest) (Clicks, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Clicks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetClicksForBitlink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}/clicks"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetClicksSummaryForBitlinkRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	bitlink       string
	unit          *TimeUnit
	units         *int32
	unitReference *string
}

// A unit of time
func (r ApiGetClicksSummaryForBitlinkRequest) Unit(unit TimeUnit) ApiGetClicksSummaryForBitlinkRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetClicksSummaryForBitlinkRequest) Units(units int32) ApiGetClicksSummaryForBitlinkRequest {
	r.units = &units
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetClicksSummaryForBitlinkRequest) UnitReference(unitReference string) ApiGetClicksSummaryForBitlinkRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetClicksSummaryForBitlinkRequest) Execute() (ClicksSummary, *_nethttp.Response, error) {
	return r.ApiService.GetClicksSummaryForBitlinkExecute(r)
}

/*
GetClicksSummaryForBitlink GetByCountries a Clicks Summary for a Bitlink

Returns the click counts for the specified link rolled up into a single field.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetClicksSummaryForBitlinkRequest
*/
func (a *BitlinksApiService) GetClicksSummaryForBitlink(ctx _context.Context, bitlink string) ApiGetClicksSummaryForBitlinkRequest {
	return ApiGetClicksSummaryForBitlinkRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return ClicksSummary
func (a *BitlinksApiService) GetClicksSummaryForBitlinkExecute(r ApiGetClicksSummaryForBitlinkRequest) (ClicksSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClicksSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetClicksSummaryForBitlink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}/clicks/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetricsForBitlinkByCitiesRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	bitlink       string
	unit          *TimeUnit
	units         *int32
	size          *int32
	unitReference *string
}

// A unit of time
func (r ApiGetMetricsForBitlinkByCitiesRequest) Unit(unit TimeUnit) ApiGetMetricsForBitlinkByCitiesRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetMetricsForBitlinkByCitiesRequest) Units(units int32) ApiGetMetricsForBitlinkByCitiesRequest {
	r.units = &units
	return r
}

// The quantity of items to be be returned
func (r ApiGetMetricsForBitlinkByCitiesRequest) Size(size int32) ApiGetMetricsForBitlinkByCitiesRequest {
	r.size = &size
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetMetricsForBitlinkByCitiesRequest) UnitReference(unitReference string) ApiGetMetricsForBitlinkByCitiesRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetMetricsForBitlinkByCitiesRequest) Execute() (CityMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetMetricsForBitlinkByCitiesExecute(r)
}

/*
GetMetricsForBitlinkByCities GetByCountries Metrics for a Bitlink by City

Returns the city origins of click traffic for the specified link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetMetricsForBitlinkByCitiesRequest
*/
func (a *BitlinksApiService) GetMetricsForBitlinkByCities(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByCitiesRequest {
	return ApiGetMetricsForBitlinkByCitiesRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return CityMetrics
func (a *BitlinksApiService) GetMetricsForBitlinkByCitiesExecute(r ApiGetMetricsForBitlinkByCitiesRequest) (CityMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CityMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetMetricsForBitlinkByCities")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}/cities"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v UpgradeRequired
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetricsForBitlinkByCountriesRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	bitlink       string
	unit          *TimeUnit
	units         *int32
	size          *int32
	unitReference *string
}

// A unit of time
func (r ApiGetMetricsForBitlinkByCountriesRequest) Unit(unit TimeUnit) ApiGetMetricsForBitlinkByCountriesRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetMetricsForBitlinkByCountriesRequest) Units(units int32) ApiGetMetricsForBitlinkByCountriesRequest {
	r.units = &units
	return r
}

// The quantity of items to be be returned
func (r ApiGetMetricsForBitlinkByCountriesRequest) Size(size int32) ApiGetMetricsForBitlinkByCountriesRequest {
	r.size = &size
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetMetricsForBitlinkByCountriesRequest) UnitReference(unitReference string) ApiGetMetricsForBitlinkByCountriesRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetMetricsForBitlinkByCountriesRequest) Execute() (ClickMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetMetricsForBitlinkByCountriesExecute(r)
}

/*
GetMetricsForBitlinkByCountries GetByCountries Metrics for a Bitlink by Country

Returns the country origins of click traffic for the specified link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetMetricsForBitlinkByCountriesRequest
*/
func (a *BitlinksApiService) GetMetricsForBitlinkByCountries(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByCountriesRequest {
	return ApiGetMetricsForBitlinkByCountriesRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return ClickMetrics
func (a *BitlinksApiService) GetMetricsForBitlinkByCountriesExecute(r ApiGetMetricsForBitlinkByCountriesRequest) (ClickMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClickMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetMetricsForBitlinkByCountries")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}/countries"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetricsForBitlinkByDevicesRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	bitlink       string
	unit          *TimeUnit
	units         *int32
	size          *int32
	unitReference *string
}

// A unit of time
func (r ApiGetMetricsForBitlinkByDevicesRequest) Unit(unit TimeUnit) ApiGetMetricsForBitlinkByDevicesRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetMetricsForBitlinkByDevicesRequest) Units(units int32) ApiGetMetricsForBitlinkByDevicesRequest {
	r.units = &units
	return r
}

// The quantity of items to be be returned
func (r ApiGetMetricsForBitlinkByDevicesRequest) Size(size int32) ApiGetMetricsForBitlinkByDevicesRequest {
	r.size = &size
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetMetricsForBitlinkByDevicesRequest) UnitReference(unitReference string) ApiGetMetricsForBitlinkByDevicesRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetMetricsForBitlinkByDevicesRequest) Execute() (DeviceMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetMetricsForBitlinkByDevicesExecute(r)
}

/*
GetMetricsForBitlinkByDevices GetByCountries Metrics for a Bitlink by Device Type

Returns the device types generating click traffic to the specified link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetMetricsForBitlinkByDevicesRequest
*/
func (a *BitlinksApiService) GetMetricsForBitlinkByDevices(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByDevicesRequest {
	return ApiGetMetricsForBitlinkByDevicesRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return DeviceMetrics
func (a *BitlinksApiService) GetMetricsForBitlinkByDevicesExecute(r ApiGetMetricsForBitlinkByDevicesRequest) (DeviceMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeviceMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetMetricsForBitlinkByDevices")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v UpgradeRequired
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetricsForBitlinkByReferrersRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	bitlink       string
	unit          *TimeUnit
	units         *int32
	size          *int32
	unitReference *string
}

// A unit of time
func (r ApiGetMetricsForBitlinkByReferrersRequest) Unit(unit TimeUnit) ApiGetMetricsForBitlinkByReferrersRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetMetricsForBitlinkByReferrersRequest) Units(units int32) ApiGetMetricsForBitlinkByReferrersRequest {
	r.units = &units
	return r
}

// The quantity of items to be be returned
func (r ApiGetMetricsForBitlinkByReferrersRequest) Size(size int32) ApiGetMetricsForBitlinkByReferrersRequest {
	r.size = &size
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetMetricsForBitlinkByReferrersRequest) UnitReference(unitReference string) ApiGetMetricsForBitlinkByReferrersRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetMetricsForBitlinkByReferrersRequest) Execute() (ClickMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetMetricsForBitlinkByReferrersExecute(r)
}

/*
GetMetricsForBitlinkByReferrers GetByCountries Metrics for a Bitlink by Referrers

Returns referrer click counts for the specified link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetMetricsForBitlinkByReferrersRequest
*/
func (a *BitlinksApiService) GetMetricsForBitlinkByReferrers(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByReferrersRequest {
	return ApiGetMetricsForBitlinkByReferrersRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return ClickMetrics
func (a *BitlinksApiService) GetMetricsForBitlinkByReferrersExecute(r ApiGetMetricsForBitlinkByReferrersRequest) (ClickMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClickMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetMetricsForBitlinkByReferrers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}/referrers"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetricsForBitlinkByReferrersByDomainsRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	bitlink       string
	unit          *TimeUnit
	units         *int32
	size          *int32
	unitReference *string
}

// A unit of time
func (r ApiGetMetricsForBitlinkByReferrersByDomainsRequest) Unit(unit TimeUnit) ApiGetMetricsForBitlinkByReferrersByDomainsRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetMetricsForBitlinkByReferrersByDomainsRequest) Units(units int32) ApiGetMetricsForBitlinkByReferrersByDomainsRequest {
	r.units = &units
	return r
}

// The quantity of items to be be returned
func (r ApiGetMetricsForBitlinkByReferrersByDomainsRequest) Size(size int32) ApiGetMetricsForBitlinkByReferrersByDomainsRequest {
	r.size = &size
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetMetricsForBitlinkByReferrersByDomainsRequest) UnitReference(unitReference string) ApiGetMetricsForBitlinkByReferrersByDomainsRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetMetricsForBitlinkByReferrersByDomainsRequest) Execute() (ReferrersByDomains, *_nethttp.Response, error) {
	return r.ApiService.GetMetricsForBitlinkByReferrersByDomainsExecute(r)
}

/*
GetMetricsForBitlinkByReferrersByDomains GetByCountries Metrics for a Bitlink by Referrers by Domain

Returns click metrics grouped by referrers for the specified link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetMetricsForBitlinkByReferrersByDomainsRequest
*/
func (a *BitlinksApiService) GetMetricsForBitlinkByReferrersByDomains(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByReferrersByDomainsRequest {
	return ApiGetMetricsForBitlinkByReferrersByDomainsRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return ReferrersByDomains
func (a *BitlinksApiService) GetMetricsForBitlinkByReferrersByDomainsExecute(r ApiGetMetricsForBitlinkByReferrersByDomainsRequest) (ReferrersByDomains, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReferrersByDomains
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetMetricsForBitlinkByReferrersByDomains")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}/referrers_by_domains"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetricsForBitlinkByReferringDomainsRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	bitlink       string
	unit          *TimeUnit
	units         *int32
	size          *int32
	unitReference *string
}

// A unit of time
func (r ApiGetMetricsForBitlinkByReferringDomainsRequest) Unit(unit TimeUnit) ApiGetMetricsForBitlinkByReferringDomainsRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetMetricsForBitlinkByReferringDomainsRequest) Units(units int32) ApiGetMetricsForBitlinkByReferringDomainsRequest {
	r.units = &units
	return r
}

// The quantity of items to be be returned
func (r ApiGetMetricsForBitlinkByReferringDomainsRequest) Size(size int32) ApiGetMetricsForBitlinkByReferringDomainsRequest {
	r.size = &size
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetMetricsForBitlinkByReferringDomainsRequest) UnitReference(unitReference string) ApiGetMetricsForBitlinkByReferringDomainsRequest {
	r.unitReference = &unitReference
	return r
}

func (r ApiGetMetricsForBitlinkByReferringDomainsRequest) Execute() (ClickMetrics, *_nethttp.Response, error) {
	return r.ApiService.GetMetricsForBitlinkByReferringDomainsExecute(r)
}

/*
GetMetricsForBitlinkByReferringDomains GetByCountries Metrics for a Bitlink by Referring Domains

Returns the referring domain click counts for the specified link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiGetMetricsForBitlinkByReferringDomainsRequest
*/
func (a *BitlinksApiService) GetMetricsForBitlinkByReferringDomains(ctx _context.Context, bitlink string) ApiGetMetricsForBitlinkByReferringDomainsRequest {
	return ApiGetMetricsForBitlinkByReferringDomainsRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return ClickMetrics
func (a *BitlinksApiService) GetMetricsForBitlinkByReferringDomainsExecute(r ApiGetMetricsForBitlinkByReferringDomainsRequest) (ClickMetrics, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ClickMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetMetricsForBitlinkByReferringDomains")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}/referring_domains"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.unit == nil {
		return localVarReturnValue, nil, reportError("unit is required and must be specified")
	}
	if r.units == nil {
		return localVarReturnValue, nil, reportError("units is required and must be specified")
	}

	localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSortedBitlinksRequest struct {
	ctx           _context.Context
	ApiService    BitlinksApi
	groupGuid     string
	sort          string
	unit          *TimeUnit
	units         *int32
	unitReference *string
	size          *int32
}

// A unit of time
func (r ApiGetSortedBitlinksRequest) Unit(unit TimeUnit) ApiGetSortedBitlinksRequest {
	r.unit = &unit
	return r
}

// An integer representing the time units to query data for. pass -1 to return all units of time.
func (r ApiGetSortedBitlinksRequest) Units(units int32) ApiGetSortedBitlinksRequest {
	r.units = &units
	return r
}

// An ISO-8601 timestamp, indicating the most recent time for which to pull metrics. Will default to current time.
func (r ApiGetSortedBitlinksRequest) UnitReference(unitReference string) ApiGetSortedBitlinksRequest {
	r.unitReference = &unitReference
	return r
}

// The quantity of items to be be returned
func (r ApiGetSortedBitlinksRequest) Size(size int32) ApiGetSortedBitlinksRequest {
	r.size = &size
	return r
}

func (r ApiGetSortedBitlinksRequest) Execute() (SortedLinks, *_nethttp.Response, error) {
	return r.ApiService.GetSortedBitlinksExecute(r)
}

/*
GetSortedBitlinks Retrieve Sorted Bitlinks for Group

Returns a list of Bitlinks sorted by group.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @param sort The type of sorting that you would like to do
 @return ApiGetSortedBitlinksRequest
*/
func (a *BitlinksApiService) GetSortedBitlinks(ctx _context.Context, groupGuid string, sort string) ApiGetSortedBitlinksRequest {
	return ApiGetSortedBitlinksRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
		sort:       sort,
	}
}

// Execute executes the request
//  @return SortedLinks
func (a *BitlinksApiService) GetSortedBitlinksExecute(r ApiGetSortedBitlinksRequest) (SortedLinks, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SortedLinks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.GetSortedBitlinks")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/bitlinks/{sort}"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sort"+"}", _neturl.PathEscape(parameterToString(r.sort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.unit != nil {
		localVarQueryParams.Add("unit", parameterToString(*r.unit, ""))
	}
	if r.units != nil {
		localVarQueryParams.Add("units", parameterToString(*r.units, ""))
	}
	if r.unitReference != nil {
		localVarQueryParams.Add("unit_reference", parameterToString(*r.unitReference, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBitlinkRequest struct {
	ctx         _context.Context
	ApiService  BitlinksApi
	bitlink     string
	bitlinkBody *BitlinkBody
}

func (r ApiUpdateBitlinkRequest) BitlinkBody(bitlinkBody BitlinkBody) ApiUpdateBitlinkRequest {
	r.bitlinkBody = &bitlinkBody
	return r
}

func (r ApiUpdateBitlinkRequest) Execute() (BitlinkBody, *_nethttp.Response, error) {
	return r.ApiService.UpdateBitlinkExecute(r)
}

/*
UpdateBitlink Update a Bitlink

Updates fields in the specified link.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bitlink A Bitlink made of the domain and hash
 @return ApiUpdateBitlinkRequest
*/
func (a *BitlinksApiService) UpdateBitlink(ctx _context.Context, bitlink string) ApiUpdateBitlinkRequest {
	return ApiUpdateBitlinkRequest{
		ApiService: a,
		ctx:        ctx,
		bitlink:    bitlink,
	}
}

// Execute executes the request
//  @return BitlinkBody
func (a *BitlinksApiService) UpdateBitlinkExecute(r ApiUpdateBitlinkRequest) (BitlinkBody, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BitlinkBody
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.UpdateBitlink")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bitlinks/{bitlink}"
	localVarPath = strings.Replace(localVarPath, "{"+"bitlink"+"}", _neturl.PathEscape(parameterToString(r.bitlink, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.bitlinkBody == nil {
		return localVarReturnValue, nil, reportError("bitlinkBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bitlinkBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v UnprocessableEntity
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v UpgradeRequired
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBitlinksByGroupRequest struct {
	ctx               _context.Context
	ApiService        BitlinksApi
	groupGuid         string
	bulkUpdateRequest *BulkUpdateRequest
}

func (r ApiUpdateBitlinksByGroupRequest) BulkUpdateRequest(bulkUpdateRequest BulkUpdateRequest) ApiUpdateBitlinksByGroupRequest {
	r.bulkUpdateRequest = &bulkUpdateRequest
	return r
}

func (r ApiUpdateBitlinksByGroupRequest) Execute() (BulkUpdate, *_nethttp.Response, error) {
	return r.ApiService.UpdateBitlinksByGroupExecute(r)
}

/*
UpdateBitlinksByGroup Bulk update bitlinks

Bulk update can add or remove tags or archive up to 100 links at a time; The response includes a a list of bitlink ids that were updated.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupGuid A GUID for a Bitly group
 @return ApiUpdateBitlinksByGroupRequest
*/
func (a *BitlinksApiService) UpdateBitlinksByGroup(ctx _context.Context, groupGuid string) ApiUpdateBitlinksByGroupRequest {
	return ApiUpdateBitlinksByGroupRequest{
		ApiService: a,
		ctx:        ctx,
		groupGuid:  groupGuid,
	}
}

// Execute executes the request
//  @return BulkUpdate
func (a *BitlinksApiService) UpdateBitlinksByGroupExecute(r ApiUpdateBitlinksByGroupRequest) (BulkUpdate, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BulkUpdate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BitlinksApiService.UpdateBitlinksByGroup")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{group_guid}/bitlinks"
	localVarPath = strings.Replace(localVarPath, "{"+"group_guid"+"}", _neturl.PathEscape(parameterToString(r.groupGuid, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.bulkUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("bulkUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bulkUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Forbidden
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v UnprocessableEntity
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v TemporarilyUnavailable
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v InternalError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
